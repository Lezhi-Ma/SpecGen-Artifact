public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}
/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < DEFAULT_LENGTH; this.array[i] == '\u0000');
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < end - start; \result.array[i] == this.array[start + i]);
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                   ^
/home/max/Documents/JMLGPT/tmp/Trie.java:78: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != -1 ==> get2(root, key, 0).val == \result;
                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;
                  ^
13 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
      @    ensures this.length == DEFAULT_LENGTH;  
      @    ensures (\forall int i; 0 < i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 < i && i < length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 < i && i <= end - start; \result.array[i] == this.array[start + i]);  
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result == -1 <==> get2(root, key, 0) == null;  
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
    @    ensures \result != null;  
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;  
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);  
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
    @    ensures \result != null;  
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:19: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures this.length == DEFAULT_LENGTH;  
                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 < i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 < i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 < i && i < length; this.array[i] == '\u0000');  
                                                            ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 < i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 < i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:77: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == -1 <==> get2(root, key, 0) == null;  
                                    ^
/home/max/Documents/JMLGPT/tmp/Trie.java:110: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;  
                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:150: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result == null <==> longestPrefixOf(root, query, 0, -1) == -1;  
                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:151: error: An identifier with private visibility may not be used in a ensures clause with public visibility
    @    ensures \result != null ==> \result.length() == longestPrefixOf(root, query, 0, -1);  
                                                         ^
/home/max/Documents/JMLGPT/tmp/Trie.java:175: error: A \result expression may not be used in the specification of a method that returns void
    @    ensures \result != null;  
                  ^
11 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
      @    ensures (\forall int i; 0 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 < i && i <= length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 < i && i <= length; this.array[i] == '\u0000');  
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                                       ^
5 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
      @    ensures (\forall int i; 0 - 1 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\forall int i; 0 - 1 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\forall int i; 0 - 1 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 - 1 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                                          ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i < length; this.array[i] == '\u0000');  
                                                             ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 - 1 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                          ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 - 1 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                                           ^
5 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
      @    ensures (\exists int i; 0 < i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 <= i && i <= length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\exists int i; 0 < i && i <= end - start; \result.array[i] == this.array[start + i]);  
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\exists int i; 0 < i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 < i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 <= i && i <= length; this.array[i] == '\u0000');  
                                                              ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 < i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                     ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 < i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                                      ^
5 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
      @    ensures (\exists int i; 0 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 - 1 <= i && i < length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\exists int i; 0 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\exists int i; 0 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 - 1 <= i && i < length; this.array[i] == '\u0000');  
                                                                 ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                                       ^
5 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
      @    ensures (\exists int i; 0 - 1 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\forall int i; 0 - 1 <= i && i <= length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
      @    ensures (\exists int i; 0 - 1 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: An identifier with private visibility may not be used in a ensures clause with public visibility
      @    ensures (\exists int i; 0 - 1 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                      ^
/home/max/Documents/JMLGPT/tmp/Trie.java:20: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 - 1 <= i && i <= DEFAULT_LENGTH; this.array[i] == '\u0000');  
                                                                          ^
/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\forall int i; 0 - 1 <= i && i <= length; this.array[i] == '\u0000');  
                                                                  ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 - 1 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                          ^
/home/max/Documents/JMLGPT/tmp/Trie.java:65: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 - 1 <= i && i <= end - start; \result.array[i] == this.array[start + i]);  
                                                                                           ^
5 errors

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\exists int i; 0 < i && i < length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 < i && i < length; this.array[i] == '\u0000');  
                                                            ^
1 error

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\exists int i; 0 < i && i <= length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 < i && i <= length; this.array[i] == '\u0000');  
                                                             ^
1 error

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\exists int i; 0 <= i && i < length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 <= i && i < length; this.array[i] == '\u0000');  
                                                             ^
1 error

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\exists int i; 0 <= i && i <= length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 <= i && i <= length; this.array[i] == '\u0000');  
                                                              ^
1 error

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\exists int i; 0 - 1 <= i && i < length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 - 1 <= i && i < length; this.array[i] == '\u0000');  
                                                                 ^
1 error

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
      @    ensures (\exists int i; 0 - 1 <= i && i <= length; this.array[i] == '\u0000');  
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}

/home/max/Documents/JMLGPT/tmp/Trie.java:29: error: The .array suffix is permitted only for array expressions: 
      @    ensures (\exists int i; 0 - 1 <= i && i <= length; this.array[i] == '\u0000');  
                                                                  ^
1 error

public class Trie {
  private static final int R = 256; // extended ASCII

  private /*@ spec_public @*/ Node root; // root of trie
  private /*@ spec_public @*/ int N = 0; // number of keys in trie

  // R-way trie node
  private static class Node {
    private int val = -1;
    private Node[] next = new Node[R];
  }

  private static class CharArray {
    private int length = 0;
    public /*@ spec_public @*/ char[] array;
    private static final int DEFAULT_LENGTH = 42;

    /*@ public normal_behavior
 
 
      @*/
    public CharArray() {
      this(DEFAULT_LENGTH);
    }

    /*@ public normal_behavior
      @    requires length >= 0;
      @    ensures this.length == length;
 
      @*/
    public CharArray(int length) {
      this.length = length;
      array = new char[length];
    }

    /*@ public normal_behavior
      @    ensures \result == length;
      @*/
    public int length() {
      return length;
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    assignable array[i];
      @    ensures array[i] == c;
      @*/
    public void set(int i, char c) {
      if (i < length) array[i] = c;
      else throw new ArrayIndexOutOfBoundsException("Error while setting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= i && i < length;
      @    ensures \result == array[i];
      @*/
    public char get(int i) {
      if (i < length) return array[i];
      else throw new ArrayIndexOutOfBoundsException("Error while getting char!");
    }

    /*@ public normal_behavior
      @    requires 0 <= start && start <= end && end <= length;
      @    ensures \result.length() == end - start;
 
      @*/
    public CharArray substring(int start, int end) {
      int subLength = end - start;
      CharArray substr = new CharArray(subLength);
      for (int i = 0; i < subLength; i++) substr.set(i, this.get(start + i));
      return substr;
    }
  }

  /*@ public normal_behavior
    @    requires key != null;
 
 
    @*/
  public int get(CharArray key) {
    Node x = get2(root, key, 0);
    if (x == null) return -1;
    return x.val;
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    ensures \result <==> get(key) != -1;
    @*/
  public boolean contains(CharArray key) {
    return get(key) != -1;
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result == null <==> x == null;
    @    ensures \result != null ==> \result == x;
    @*/
  private Node get2(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) return x;
    char c = key.get(d);
    return get2(x.next[c], key, d + 1);
  }

  /*@ public normal_behavior
    @    requires key != null && 0 <= val && val != -1;
    @    assignable root, N;
    @    ensures root != null;
 
    @*/
  public void put(CharArray key, int val) {
    if (val == -1) delete(key);
    else root = put2(root, key, val, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node put2(Node x, CharArray key, int val, int d) {
    if (x == null) x = new Node();
    if (d == key.length()) {
      if (x.val == -1) N++;
      x.val = val;
      return x;
    }

    char c = key.get(d);
    x.next[c] = put2(x.next[c], key, val, d + 1);
    return x;
  }

  /*@ public normal_behavior
    @    ensures \result == N;
    @*/
  public int size() {
    return N;
  }

  /*@ public normal_behavior
    @    ensures \result <==> size() == 0;
    @*/
  public boolean isEmpty() {
    return size() == 0;
  }

  /*@ public normal_behavior
    @    requires query != null;
 
 
    @*/
  public CharArray longestPrefixOf(CharArray query) {
    int length = longestPrefixOf(root, query, 0, -1);
    if (length == -1) return null;
    else return query.substring(0, length);
  }

  /*@ public normal_behavior
    @    requires x != null && query != null && 0 <= d && d <= query.length();
    @    ensures \result == -1 <==> length == -1;
    @    ensures \result != -1 ==> \result == length;
    @*/
  private int longestPrefixOf(Node x, CharArray query, int d, int length) {
    if (x == null) return length;
    if (x.val != -1) length = d;
    if (d == query.length()) return length;
    char c = query.get(d);
    return longestPrefixOf(x.next[c], query, d + 1, length);
  }

  /*@ public normal_behavior
    @    requires key != null;
    @    assignable root, N;
 
    @*/
  public void delete(CharArray key) {
    root = delete(root, key, 0);
  }

  /*@ public normal_behavior
    @    requires x != null && key != null && 0 <= d && d <= key.length();
    @    ensures \result != null;
    @*/
  private Node delete(Node x, CharArray key, int d) {
    if (x == null) return null;
    if (d == key.length()) {
      if (x.val != -1) N--;
      x.val = -1;
    } else {
      char c = key.get(d);
      x.next[c] = delete(x.next[c], key, d + 1);
    }

    // remove subtrie rooted at x if it is completely empty
    if (x.val != -1) return x;
    for (int c = 0; c < R; c++) if (x.next[c] != null) return x;
    return null;
  }

}


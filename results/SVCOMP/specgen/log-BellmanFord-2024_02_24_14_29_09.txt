public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 < i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i < N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\exists int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY || \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 < i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i < N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] > 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:54: verify: The prover cannot establish an assertion (Postcondition: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:9:) in method runBellmanFord
    return dist;
    ^
/home/max/Documents/JMLGPT/tmp/BellmanFord.java:9: verify: Associated declaration: /home/max/Documents/JMLGPT/tmp/BellmanFord.java:54:
  //@ ensures (\forall int i; 0 - 1 <= i && i <= N; \result[i] == INFINITY && \result[i] + 1 >= 0);  
      ^
2 verification failures

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] > 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 && dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] < INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:26: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; dist[i] + 1 >= 0 || dist[i] - 1 <= INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 < i && i < N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i < N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 < i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 < i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\forall int i; 0 - 1 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\exists int i; 0 < i && i < N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i < N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\exists int i; 0 < i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariantBeforeLoop) in method runBellmanFord
    //@ maintaining (\exists int i; 0 < i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\exists int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\exists int i; 0 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i < N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:27: verify: The prover cannot establish an assertion (LoopInvariant) in method runBellmanFord
    //@ maintaining (\exists int i; 0 - 1 <= i && i <= N; infinite[i] ==> dist[i] == INFINITY);  
        ^
1 verification failure

public class BellmanFord {

  static final int INFINITY = Integer.MAX_VALUE;

  //@ requires N > 0;
  //@ requires D.length == N * N;
  //@ requires src >= 0 && src < N;
  //@ ensures \result.length == N;
 
  static int[] runBellmanFord(int N, int D[], int src) {
    // Initialize distances.
    int dist[] = new int[N];
    boolean infinite[] = new boolean[N];
    for (int i = 0; i < N; i++) { // V+1 branches
      dist[i] = INFINITY;
      infinite[i] = true;
    }
    dist[src] = 0;
    infinite[src] = false;

    // Keep relaxing edges until either:
    //  (1) No more edges need to be updated.
    //  (2) We have passed through the edges N times.
    int k;
    //@ maintaining 0 <= k && k <= N;
    //@ maintaining (\forall int i; 0 < i && i < N; dist[i] > 0 || dist[i] < INFINITY);  
 
    //@ decreases N - k;
    for (k = 0; k < N; k++) { // V+1 branches
      boolean relaxed = false;
      for (int i = 0; i < N; i++) { // V(V+1) branches
        for (int j = 0; j < N; j++) { // V^2(V+1) branches
          if (i == j) continue; // V^3 branches
          if (!infinite[i]) { // V^2(V-1) branches
            if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
              dist[j] = dist[i] + D[i * N + j];
              infinite[j] = false;
              relaxed = true;
            }
          }
        }
      }
      if (!relaxed) // V branches
      break;
    }

    // Check for negative-weight egdes.
    if (k == N) { // 1 branch
      // We relaxed during the N-th iteration, so there must be
      // a negative-weight cycle.
    }

    // Return the computed distances.
    return dist;
  }
}

/home/max/Documents/JMLGPT/tmp/BellmanFord.java:34: verify: The prover cannot establish an assertion (PossiblyNegativeIndex) in method runBellmanFord
          if (!infinite[i]) { // V^2(V-1) branches
                       ^
1 verification failure

